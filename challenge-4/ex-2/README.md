**самостоятелна работа**

# Работа с функции

## Работа с callback функции и колекции

**#(1):** Обхождането на колекции е процес по преминаване, през всички налични елементи на един масив или обект. Напишете имплементация на функцията forEach, която приема следните аргументи:
колекция която трябва да се обходи
Функция, (callback) която трябва да се изпълни за работа с елемента

**Примерен код:**
```javascript
forEach([1,2,3,4], function(element) {
	console.log(element)
});
```
*Примерен изход:*
```javascript
1
2
3
4
```


**#(2):** Когато работим с колекции често ни се налага да елиминираме определени елементи и да обработваме само тези, които отговарят на определено условие. За тази цел е необходимо да създадем нова колекция от вече съществуващата.
 
Например необходими са ни  всички четни числа в даден масив, или всички числа които са по-големи от дадена стойност.
 
Напишете имплементация на функцията **filter**, която приема следните аргументи:
колекция която трябва да се обходи
Функция (callback) която трябва да се изпълни за работа с елемента
Функцията връща като резултат, нова колекция, копие на първата.

**Примерен код:**
```javascript
filter([1,2,3,4], function(element) {
   return (element % 2 == 0)
});
```

*Примерен изход:*
```javascript
[2, 4]
```

**#(3):** Напишете имплементация на функцията **map**. Функцията приема callback който да трансформира, входните данни от масива, базирайки се на функция и връща нова колекция, с нови стойности
Примерен код
 
**Примерен код:**
```javascript
map([1,2,3,4], function(element) {
   return (element * 2)
});
```

*Примерен изход:*
```javascript
[1, 4, 6, 8]
```

**#(4):** Много е дразнещо когато, трябва да напълним колекцията си с примерни данни за да я ползваме в нашите експерименти, но не можем да измислим повече от 10 числа. Време е да автоматизираме този процес. 

Напишете имплементация на функцията **fill**, която пълни колекция със случайно генерирани стойности.

Функцията приема като първи аргумент колекция, в която ще съхраняваме стойностите си. Колекцията може да съдържа елементи а може и да е празна.

Като втори аргумент функцията приема колекция от символи, които ще бъдат ползвани като своеобразен източник на данни с която ще напълним колекцията.

Функцията приема трети аргумент, дължина на резултатната колекция. Брой случайно генерирани символи които ще бъдат добавени към колекцията. Ако символите в колекцията са повече от аргумента, то функцията връща резултатната колекция без промяна
 
**Примерен код:**
```javascript
fill([],[‘a’, ‘b’, ‘c’, 1, 10, 8, 7, 10], 5);
```

*Примерен изход:*
```javascript
[‘a’, ‘a’, ‘a’, 10, 1]
```
 
**Примерен код:**
```javascript
fill([1, 2, 5, 6, 7 , 8, 8, 8],[‘a’, ‘b’, ‘c’, 1, 10, 8, 7, 10], 5);
```

*Примерен изход:*
```javascript
[1, 2, 5, 6, 7, 8, 8, 8]
```

**#(5):** Напишете имплементация на функцията **reverse**. Функцията има за цел да вземе колекция с елементи и да промени тяхното позициониране в колекцията.

**Примерен код:**
```javascript
reverse([‘a’, ‘b’, ‘c’, 1, 10, 8, 7, 10]);
```

*Примерен изход:*
```javascript
 [10, 7, 8, 10, 1, ‘c’, ‘b’, ‘a’]
```

Функцията трябва да приема колекция от колекции, които да могат да бъдат преобърнати.

**Примерен код:**
```javascript
reverse([ [1,2,3,4], [‘a’, ‘b’, ‘c’, ‘d’]]);
```
*Примерен изход:*
```javascript 
 [ [‘d’, c’, ‘b’, ‘a’] , [4,3,2,1] ]
```


## Мениджър на низове
 
Имплементирайте функция **stringBuilder** която да натрупва набор от текстова информация, който след това се визуализира от потребителя. Подходящ е когато имаме процес или цикъл от повтарящи се стъпки. Като първи и единствен аргумент функцията получава колекция от стрингови литерали, и променливи. Функцията връща резултат стрингов литерал.

**Примерен код:**
```javascript
stringBuilder([“This”, “is”, “super”, “sample”, “text”]);
```

*Примерен изход:*
```javascript 
 This is super sample text
```

Добавете втори аргумент към функцията stringBuilder която да получава декорираща анонимна функция. Целта на тази функция е да модифицира всеки един от елементите в колекцията. Пример за модификация е например конкатениране на елемент към всеки един от низовете.
 
**Примерен код:**
```javascript
stringBuilder([“This”, “is”, “super”, “sample”, “text”], function(element) {
	return [“*”, element, “*”].join();
});
```

*Примерен изход:*
```javascript 
 *This* *is* *super* *sample* *text*
```
 
Модифицирайте горното условие и имплементирайте възможност за добавяне на колекция от декоратори, които да се прилагат към отделните елементи в колекцията на базата на определени условия.
 
Примерни допълнителни условия (които можем да си измислим като програмисти)
* Ако в колекцията се съдържа число, декоратора ни ще го умножи с две
* Ако в колекцията се съдържа число, по голямо от 25, декоратора ни ще го събере със себе си, и ще върне резултата.
 
**Примерен код:**
```javascript
stringBuilder([“This”, “is”, “super”, “sample”, “text”], {
 
	“number” : function(element) {
    	return element * 10;
	},
 
	“number_25” : function(element) {
    	return (element + element);
	}
});
```